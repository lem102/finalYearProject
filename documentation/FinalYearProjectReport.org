#+options: ':nil *:t -:t ::t :t H:4 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: Final Year Project Report
#+author: Jacob Leeming
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 27.1 (Org mode 9.3)

#+latex_class: article
#+latex_class_options:
#+latex_header:

#+LATEX_HEADER: \tolerance=1
#+LATEX_HEADER: \emergencystretch=\maxdimen
#+LATEX_HEADER: \hyphenpenalty=10000
#+LATEX_HEADER: \hbadness=10000
#+LATEX_HEADER: \frenchspacing

#+LATEX_HEADER: \usepackage{apacite}
#+LATEX_HEADER: \usepackage{natbib}
#+LATEX_HEADER: \usepackage{minted}
#+latex_header: \bibliographystyle{apacite}

#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_compiler: pdflatex
#+date: \today

* Introduction
** Problem Statement

In the world of computer science, and computer programming in general,
there is an abundance of learning materials freely available from which
students can learn how to program, how to use a certain programming language,
how to use a framework for that language, etc.. One area of study that
is not as well developed in terms of learning materials is compiler design.
It would be unfair to say that there is nothing for a beginner to make
use of, however these resources have a tendency to ignore or gloss over
the gory details, advising that tools are used to generate complex parts
of the compiler for them. 

This is good advice, and indeed in a "real world" situation an organisation
that wanted to create a compiler would use these tools as the popular ones
are tried and tested (LLVM, a massive compilation library is used in several
mainstream languages, such as Swift and Rust. Several languages also have
LLVM implementations of their compilers, for example the C/C++ compiler
clang.), and simplify the compiler creation process immensely. However,
if a learner wished to understand what these tools did, they would need
to either read the source code of these tools (this would be difficult,
as some of the projects are massive and very complex.), or read books of
a technical nature, such as Compilers: Principles, Techniques and tools
(henceforth referred to as the Dragon Book). While the Dragon book is an
excellent resource for designing compilers, it is too dense for a learner
who wants to apply any knowledge that can be gleaned from it.

This is the problem. There is an absence of material that shows the learner
that they can create a compiler with only their own code, and without becoming
a computer science professor first!

In order to rectify this problem, I propose the following: 

** Product Description

The product that I will produce at the end of this project is a compiler
for a general purpose programming language of my own creation. The compiler
will be able to compile a program written in said programming language
into assembly language targeting the x86 CPU architecture. The compiler
will be written in a modular, easily understandable way using the Java
programming language. It will be written in this way to encourage learning
about the various stages of compilation. 

As a supplement to the compiler I will also provide a learning plan in
pdf form to demonstrate how the compiler could be used as a learning resource,
including breakdowns of the more important parts of the code base and how
they relate to the ideas featured in the design of compilers, such as tokens,
syntax trees, etc.

** Users or Audience

The users that I imagine would be interested in this project would be anyone
who is interested in the inner workings of a compiler, and how they could
go about creating their own compiler without leaning on other available
tools. As compiler design is quite a technical subject, I would expect
that the users of this project would be at university level or equivalent
in terms of their education in computer science or programmming.

* Background Research
** Necessary Background Material
*** What is a Compiler?

In short, a compiler is a computer program that converts a source program
into machine code that can be executed by a CPU. It does this by taking
its input, a program that is written in a human-readable programming language
and performing multiple actions upon it. As a result of these actions,
an executable program is produced that can be run by the computer.

*** Why Do We Use Compilers?

Back in the 1950's, programmers wrote software in assembly language. This
means that in order to tell the computer to do something, they would have
to write instructions that would change the state of specific bits in order
to do anything. This meant that even doing simple things takes a lot more
lines of code than in higher level programming languages that we have today.
For example, this C program;

#+BEGIN_SRC c
  #include <stdio.h>

  int main()
  {
      printf("Hello, World.");
  }
#+END_SRC

becomes much more complicated in assembly language \citep{assemblyHelloWorld}:

#+BEGIN_SRC asm
  global _start

  section .text

  _start:
    mov rax, 1        ; write(
    mov rdi, 1        ;   STDOUT_FILENO,
    mov rsi, msg      ;   "Hello, world!\n",
    mov rdx, msglen   ;   sizeof("Hello, world!\n")
    syscall           ; );

    mov rax, 60       ; exit(
    mov rdi, 0        ;   EXIT_SUCCESS
    syscall           ; );

  section .rodata
    msg: db "Hello, world!", 10
    msglen: equ $ - msg
#+END_SRC

This meant that programmers were a lot less productive, as they spent a
lot of time doing what we now consider trivial operations, as well as having
to create solutions to complex problems. As a consequence of this, the
price of software exceeded that of the hardware available at the time due
to how complicated and time consuming it was to make even a simple program.

Happily, this was all soon to change. In the 1950s, a man called John Backus
joined IBM as a programmer. The first project he worked on was a program
in machine code to calculate the position of the moon. Because programming
in machine code was so awful, he invented a program called SpeedCoding.
SpeedCoding is essentially a collection of macros that would reduce the
amount of time a programmer would spend on common tasks by running chunks
of code created on the fly based on a few parameters supplied by the program.
This enhanced programmer productivity, but at a cost. If a program using
SpeedCoding was running, then SpeedCoding also need to be running to "interpret"
the fancy SpeedCoding instructions. This consumed a large chunk of the
memory of the computers they had at the time, so it was deemed not practical.

After his experiments with SpeedCoding, Backus was appointed as the manager
of the Programming Research Department at IBM in 1954. During this time,
he assembled a team and developed FORTRAN. FORTRAN was the first widely
used high-level language, and it greatly simplified writing software. It
worked by taking input in the form of a simpler language which abstracted
away many of the complications caused by writing directly in assembly,
and then translated that input into assembly instructions which could then
be run on a compatible computer. This was the first practical use of a
compiler \citep{johnBackus}.

The impact of FORTRAN was massive. Kenneth Thompson, the creator of the
UNIX operating system said "95 percent of the people who programmed in
the early years would never have done it without FORTRAN." \citep{kenThompson}.
It allowed non-programmers to be able to write code, so scientists were
able to write the code for their programs without hiring a programmer to
do it for them, greatly lowering the barrier to entry for computing.

Of course the development of higher level languages continued beyond FORTRAN,
leading to other compiled languages such as C, Java, and many, many more.
These languages have iterated upon each other, gone in different directions
and had different design philosophies. But all of them exist to make it
easier for programmers to write code, and are continually developed to
make it even easier. So we owe a great deal to FORTRAN and to compilers
for making these abstractions.

*** The Structure of a Compiler

The overall structure of compilers has not changed much since the creation
of FORTRAN I, and the compiler I will create also mostly sticks to the
ideas introduced by it. The structure of a compiler is made up of several
stages:

**** Lexical Analysis

In this first stage, the source code is split into groups of characters
which have meaning called lexemes. For example, this:

#+BEGIN_SRC text
  example = 1 + 3
#+END_SRC

Would be split into the following lexemes:

#+BEGIN_SRC text
  example
  =
  1
  +
  3
#+END_SRC

Each of these lexemes are then used to create a token. Each token has a
value and a type. The variable example is stored in what is called a syntax
table at index 1. The equals sign and the addition sign both have no value,
but they are the type of an assignment operator and an addition operator
respectively. Both of the numbers have the type integer and the value of
1 and 3 respectively. This leaves us with the following tokens.

#+BEGIN_SRC text
  (id, 1)
  (assignment, =)
  (integer, 1)
  (addition, +)
  (integer, 3)
#+END_SRC

**** Syntax Analysis

After the source code has been successfully split into tokens, a syntax
tree needs to be produced using the tokens from the previous phase. The
purpose of this tree is to show how the tokens all relate to each other.
In the tokens that we have from the previous phase, the assignment token
would be the root token of the statement, the identifier before the assignment
and the expression after the assignment would be the children of the assignment
token.

**** Semantic Analysis

After the syntax tree has been created, there needs to be additional analysis
to determine the types of the various symbols referred to in the source
code, and keep this information in the syntax table. Once the types of
the symbols have been determined, a process called type checking begins.
This is where we check that the correct types are used in the correct way.
For example, if we have a string and we attempt to divide it by an integer,
we would want the compiler to throw an error as dividing a word by a number
is obviously not intended.

In some situations, for example if we are multiplying a floating point
number by an integer, we would want the type of a symbol to be converted
to another type to allow the result to be correctly stored within the syntax
table. These sort of conversions are also handled by the semantic analyser.

In addition to the checking of types, we need to check that the usage of
symbols are restricted to the correct scope. For example, if in the source
code we have an if statement in which a variable called test is declared,
we wouldn't want test to be accessable outside of the if statement, as
test would be outside of the scope of the if statement. If source code
was supplied to the compiler that attempted to refer to a variable in such
a way, then we should throw an error.

**** Intermediate Code Generator 

This stage is the final stage of the "front end" of the compiler. Now that
we have the syntax tree of the source code and the complete symbol table
of all symbols used in the source code we can generate what is called intermediate
code. Intermediate code is a sort of pseudo code that needs to have the
following two features, first one being it needs to be easy to produce,
and the other one being it needs to be easy to translate.

A common type of intermediate code is called three address code, which
is where each line of code refers to three or fewer variables. This pseudo
code is essentially the source code distilled into its very basic operations.


This:

#+BEGIN_SRC text
  example = x + y * 3
#+END_SRC

Will become something like this:

#+BEGIN_SRC text
  t1 = y * 3
  t2 = x + t1
  example = t2
#+END_SRC

This code can now be easily translated into an assembly language, as each
line only uses basic operations. But before we do that, there is an additional
stage that we must first put this intermediate code through.

**** Code Optimisation

This stage we look at the intermediate representation produced in the last
step and try to improve its efficiency. We can do this by combining certain
lines of code, so for example:

This:

#+BEGIN_SRC text
  t1 = y * 3
  t2 = x + t1
  example = t2
#+END_SRC

Could become this:

#+BEGIN_SRC text
  t1 = y * 3
  example = x + t1
#+END_SRC

There are many other techniques that can be used to optimise intermediate
representation code that can get quite complicated. Finally, we get to
the last stage:

**** Code Generation

For the code generation stage, we need to generate code in the target language
using the intermediate representation that we have produced from the previous
steps. Exactly what is done here depends on the target language, if we
are targeting machine code then we will need to decide what registers will
hold the variables used in the program. After the variables have been sorted
out, then code in the target language is generated that performs the exact
same operations that were specified in each line of the intermediate code.

**** The Symbol Table

Throughout the process of compilation, a data structure known as the symbol
table is used to store all information about any symbols referred to in
the source code. These symbols tend to be identifiers for variables or
function names. Because we are going to compile the code into a different
target language it is important that for all of the symbols pertaining
to variables, their types and the scope of the variable are correctly stored.
Then for symbols pertaining to functions we must store the required parameters
of the function and the types of those parameters.

All of this information is gathered during the syntax analysis phase and
validated during the semantic analysis phase. The data within the syntax
table is important throughout nearly all the phases of compilation \citep{dragon}.

*** Other Topics to Aid Understanding

To understand the source code aspect of my project, a reader would need
to understand basic programming concepts such as what a statement is, how
basic logic such as if statements and loop statements work, and be decently
familiar with either Java or another mainly object oriented language (for
example, C#). They would also need to understand object oriented concepts,
such as classes, objects and inheritance. A basic understanding of assembly
would also be useful for the later parts of the compiler where we are creating
machine code, but I will be documenting these quite intensely and intend
to make them as simple as possible.

I would also recommend reading the first chapter of Compilers: Principles
techniques and tools (AKA The Dragon Book) \citep{dragon}. This chapter
gives an overview of the various components of a compiler and the different
transformations that the code that is being compiled needs to undergo before
it can be processed by the CPU. An especially useful resource to understand
these concepts is figure 1.7, which can be found on page 7. This figure
shows how the code to be compiled will look through the various stages
of compilation.

Other topics of interest that are located within this chapter are the concepts
of tokens, syntax trees and intermediate representation. These are what
the source code of this project will be attempting to produce and then
use in later parts of the compiler input's journey through the compiler.

** Related Work
 
*** A Compiler for Teaching about Compilers

This paper sounds like it has a comparable spirit to this project in that
it espouses similar ideas regarding how the use of compiler creation tools
effect educational benefits, but the paper discusses a compiler that is
designed in order to teach a course, whereas mine is simply a resource
from which you can see how a compiler could be implemented without the
use of compiler creation tools \citep{compilerForTeachingCompilers}.

The compiler in this course is designed to be very modular, so that a student
on the course could take out a component of the compiler and replace it
with their own. This also means that the student would be able to replace
parts of their own work with the teachers, which could be useful if they
wanted to see how that part of the compiler is supposed to function.

This project and my project are similar in that they both involve creating
a compiler that needs to be modular and simple to understand so that students
can learn the basic concepts of how compilers work from reading the provided
source code. This means that both projects will need to have clean, readable
code.

The projects differ in their purpose, however. My project is simply a supplement
to an existing course, or perhaps just an example to showcase the inputs
and outputs of different steps of compilation. The project described in
the paper is meant to be at the centre of a university module, and is designed
to be extremely modular to the point that students can remove some component
and replace it with their own. Although my compiler will try to be modular
in order to encourage experimentation, it is not the primary focus of my
project, which is to demonstrate that a compiler can be built without needing
lots of theoretical knowledge.

*** A Set Of Tools To Teach Compiler Construction

This paper introduces a set of tools to aid in the teaching of compilers,
as the authors of the paper found that some of the tools commonly used
in compiler construction were either obsolete or lacking in terms of educational
features. One example of how they remedied this is by making use of a modified
GNU bison, which outputs a detailed description of the various states the
parser is in whilst parsing the input tokens. This information was lacking
in the original bison, making it very difficult to find errors in either
the input or the parser code.

My project differs from the tools described in the above paper quite significantly.
In the paper, they still make use of tools to create code which skips over
the gory details. These tools are better for education, which is an improvement,
but I want to stick to just using a single programming language (Java)
in my project. My intention with this is to reveal how a normal student
could create a compiler with out the use of complicated tools and theories,
therefore making the student totally understand the process of compilation
\citep{aSetOfToolsToTeachCompilerConstruction}.

** Professional, Legal Ethical \amp Social Issues

A professional issue that I face is the first item in the "Show what you
know, learn what you don't" section of the bcs code of conduct: "only undertake
to do work or provide a service that is within your professional competence"
\citep{bcs}. To resolve this issue I have conducted research into the subject
matter of compilation to ensure I possess the skills to deliver a worthy
product.

An ethical issue that my project faces is the possibility of the compiler
being used to create a program that is used in an unethical way (e.g. compiling
a program that is used to perform calculations to assist in the development
of weaponry). Unfortunately, there is nothing I can do to prevent this.

My compiler will have a positive social effect, as it can be used in the
classroom to teach students. Achieving this is one of the goals of the
project.

* Project Planning
  
In this section, I will discuss the planning of this project.

** User Requirements

The first and most important part of planning a project is gathering the
user's requirements. I think the most important deliverable of this project
would be the compiler itself, so the main requirement of this project would
be a compiler that can translate code from a high level programming language
into assembly code. 

This compiler has a few sub-requirements; it must be written in a
way that is understandable to a second year computer science student, and
it must be able to show the process that source code goes through on its
journey to becoming assembly language.

The language that the compiler compiles from needs to be sufficiently complicated
so as to illustrate the main issues regarding compilation, such as operator
precedence, correct assembly generation, etc.

Given the above, from the perspective of the user, the requirements would
be:

- A compiler that compiles from a high-level language into assembly.
- Compiler is capable of showing the output of each different stage of compilation in a clear manner that illustrates the purpose of each stage.
- Source code of said compiler is easily understandable.

** Choice of Tools/Technqiues/Approach
*** Programming Language

An important decision I had to make early on is which programming language
should the compiler be written in. I chose to use Java, but considered
two other programming languages, Python and C#.

I thought Python could be a good choice for the compiler due to its prevelance
in eduction as well as its simpler syntax when compared to Java, which
would allow students to be able to better understand the code. However,
upon experimenting with the object oriented side of Python, I realised
this syntactic simplicity was only present as long as the programmer was
writing procedural code. The final nail in the coffin was when I considered
the fact that Python is a dynamically typed language, rather than being
statically typed. Given the nature of my project, I think that a dynamically
typed language would hinder me somewhat, as there will be many custom types
in use at each stage of the compiler. A statically typed language would
allow me to catch trivial bugs at compile time rather than having to waste
time debugging something breaking during runtime.

The other language that I was considering was C#. On the surface, C# is
very similar to Java. C# has many advanced language features, such as a
great deal of syntactic sugar and support for functional programming using
LINQ and lambda expressions, which increase programmer productivity, and
reduces the amount of boiler plate code that has to be written. Unfortunately,
unless you are familiar with these features, and understand what they are
doing, it is all too easy to get confused, and use them blindly without
thinking. It is also likely that students will never have used C# before,
compounding any potential confusion.

I chose Java as the implementation language of the compiler because it
is a very common language, and although its use in industry is gradually
decreasing, it is still the main language used at universities for the
purposes of teaching. Because of this, many students will be familiar with
Java, and it lowers the barrier to entry for reading the code of this project's
compiler. The other main advantage of Java is its great object oriented
features, such as polymorphism and inheritance, whcih allow for very productive
coding.

*** NASM

NASM (Netwide Assembler) is an assembler for the x86 CPU architecture \citep{nasm}.
It's purpose in my project is to assemble the assembly code outputted by
JPLcompiler into object code, which can be linked into an executable, which
can then be executed by the CPU. 

I chose NASM instead of other assemblers like GAS (GNU Assembler) or MASM
(Microsoft Assembler) for several reasons. Firstly, it works with Linux,
which is JPLcompiler's target platform and where command line programs
are first class citizens. Secondly, I think that it has the best syntax.
Thirdly, it seems that the majority of assembly programmers use it, so
there is a lot of useful information available about it \citep{gas&masm}.

*** Bash

Bash was chosen as the scripting language to write the script that automates
the building and running of JPLcompiler simply because it is the default
shell scripting language on Linux, and I have previous experience with
it.

*** Relevance to Course

The topic of compilation is an incredibly important topic in computer science
due to it being a key technology used in the implementation of high level
languages. Compilation as a process also involves the use of several algorithms
and data structures. As such, this project which involves the creation
of a compiler is highly relevant to this course.

Out of the modules studied as a part of the course, the most relevant would
be Language Translators, which was one of my inspirations for doing this
project. The module was concerned with the process of parsing a toy language
as seen in a compiler. We used a "parser generator" called javaCUP to write
Java code to create a parser that would parse the language that we had
specified.

As others have noted in the literature review, tools that automate the
process of compiler creation, such as a parser generator like javaCUP,
are unsuitable for educational purposes due to them causing students to
spend more time getting the tool to work than actually completing their
task, a theme unfortunately prevalent throughout computing generally.

This project is very relevant to the Language Translators module, as it
involves parsing, and it aims to solve one of the problems that I encountered
during my taking of that module: the lack of simple tools that aided understanding.

There are a few other relevant modules, a couple of which are from the
first year of the course. Studio 1, specifically the portion where we learned
about writing shell scripts using the bash scripting language. The things
I learned about using Linux and writing shell scripts were very helpful
to me in understanding how to automate many repetitive tasks such as automating
the compile-run cycle of this project. Another module that was useful was
the module where we were first introduced to Java, and object oriented
programming in general. In the second year of the course, Algorithms Processes
and Data further improved my Java skills, and I used some of the concepts
taught, in particular the tree concept in this project.

** Risk Management

In every project, there are risks, and this project is no exception! The
main risk to this project that I can forsee is running out of time before
the central deliverable (the compiler) is completed. As I have no experience
with writing a compiler, or writing assembly, I have no idea how long it
will take to write a given part of the codebase. There is something I can
do to mitigate this risk, however. 

As part of an ideal compiler, there would be a stage where the source code
is checked for correctness, so if a syntactical or semantical error is
found, then the compiler will emit an error message. As this compiler is
not intended for serious use, I can justify skipping over that section
in favour of the others (which have a greater educational value), and coming
back to it later if I have time.

** Product Development Plan

I think I can split the development of the compiler into four main stages,
each of which can be broken up into substages:

- the Tokeniser
  - Preparing the Source Code
  - Splitting the Prepared Source Code into Tokens
- the Parser
  - Loop Through the Tokens
  - Decide What Type of Statement
  - Populate Statement Node with Values of Following Tokens
  - Organise Nodes into a Tree Structure
- the Intermediate Code Generator
  - for Each Node of the Tree Create An Intermediate Representation
- the Assembly Generator
  - Assigning Memory
  - Converting Intermediate Code Instructions into Assembly Operations

In regards to how much time each stage of the compiler will take to write,
I suspect that the most complicated part of the code base will be the assembly
generator (mostly to do with the presence of assembly). The tokeniser should
be relatively simple, with the parser and the intermediate code generator
coming in somewhere between the tokeniser and the assembly generator. As
each stage of the project relies on the previous, I will need to write
them in order to make sure they work well together.

Considering the difficulty levels of each stage and the order in which
they have to be written, I think this is an appropriate plan:

[[./fypGanntChart2.PNG]]

* Design

Now I will discuss the design of the compiler.

** Product Specification

When thinking about how I was going to design the compiler, I had to consider
several things. How are compilers usually structured? What can I do to
build a compiler in such a way that it is easily understandable to a student?
How should I go about outputting educational output back to the user? 

As we saw in the structure of a compiler subsection earlier, the process
of compilation is split into several stages. Given this, it would make
sense to group the code by these stages, possibly putting each stage into
its own class. In doing this we make the code more modular and understandable.

However, if we picture each stage of the compilation taking an input (the
output of the previous stage of compilation or in the case of the first
stage, the source code) and returning an output for use in the next stage,
we are presented with an opportunity to take an output of a given stage
and present this output in a readable way to the user. 

If we were to allow for such output to be emitted after each stage, then
this could be very useful in explaining many compilation concepts to students,
such as tokens, abstract syntax trees and intermediate code. As the student
would be able to alter the source code that the compiler is compiling from,
they would be able to note the differences in output.

This image from the dragon book is a great illustration of the inputs and
outputs of each stage \citep{dragon}{p. 7}:

[[./compilerDesign.png]]

* Implementation
** Skills and Knowledge required for Development

To implement the compiler, I had to make use of several different skills
and bits of knowledge. In order to create anything, I first had to be able
to program. Programming requires knowledge of a programming lanugage (Java)
and a text editing program (Emacs) to write code in that programming language,
and others if necessary. To automate the many terminal commands that have
to be run to allow for the compiler to be run, I wrote a shell script which
required knowledge of the bash scripting language. 

When writing the compiler, I needed to know about the structure of a compiler
and the various transformations source code goes through during its journey
through the compiler, detailed previously in this report. Additionally,
I will need to learn at least the basics of assembly language in order
to write the code generator part of the compiler.

Another thing I needed to be aware of is the cleanliness of my code when
writing the compiler. Clean code means that it is easy to understand. Code
being easy to understand makes it easier for students to read, and also
makes it easier for me to fix any bugs that I find during the development
process.

The final, and arguably most important thing I need to know for the development
process is how to find information, whether that be in books or online.
Before starting to write any of the stages of compilation, I must first
think about how I will solve the problems each stage poses. Before I can
think about these problems, I must first read up on the common techniques
used, and figure out how I can implement them. If I do not do this and
jump blindly in, chances are I will both make very little progress and
write code that is unreadable.

** Implementation Details

In this section I will discuss my implementation of certain parts of the
compiler.

*** structure of compiler in comparison to other compilers

JPLcompiler's structure is rather bare bones compared to a traditional
compiler. Many of the steps required to enforce the correctness of the
source code have been omitted in the interest of getting JPLcompiler to
compile something within the time limit I have for this project. In a similar
manner, many mainstream compilers are "optimising compilers" [insert reference
to dragon book] as they perform several iterations over the intermediate
representation in order to produce an intermediate representation that
uses fewer instructions, and therefore generates more efficient assembly.

*** Parser

Instead of implementing a proper parsing algorithm, such as a shift-reducing
parser, I opted for a simpler approach. At the beginning of each statement,
the parser will inspect the first token of the statement to determine the
type of statement. If that is not enough to determine the type of statement,
then the following tokens is used to classify the statement. An example of
such a statement would be:

#+begin_src text
  int x = 2;
#+end_src

The first token, the integer declaration token, is not enough to determine
the type of statement, as it could be a declaration statement or a assignment
statement depending on the following tokens. In the above example, if the
third token in the sequence is an assignment token (=), then the statement
is an assignment statement, and all the tokens of the statement are passed
to a function that checks that the tokens follow the rules of the language.
If the statement involves an expression, then the tokens that belong to
that expression will be sent to an expression parsing function.

*** Expression Parsing

In the JPL langugage, there are expressions in a similar manner to C-like
languages. For example, the following expression will evalutate to 14,
which will be stored in the variable number:

#+begin_src text
int number = 2 + 3 * 4;
#+end_src

JPLcompiler parses this expression by turning it into a tree structure
to make sure that the operations are evaluated in an order that respects
operator precedence. First, it will search for the "root element" of the
expression. For example, in the following example:

#+begin_src text
2 + 3
#+end_src

The $+$ is the root element. For a more complicated example:

#+begin_src text
2 + 3 * 4 - 5
#+end_src

The * is the root element. JPLcompiler finds the root element using the
following method:

#+begin_src java
      private static int findRootElementIndex(Token[] tokens) throws JPLException {
          // Order is important.
          TokenType[] types = {
              TokenType.And,
              TokenType.Or,
              TokenType.Equal,
              TokenType.NotEqual,
              TokenType.GreaterThan,
              TokenType.LessThan,
              TokenType.GreaterThanOrEqualTo,
              TokenType.LessThanOrEqualTo,
              TokenType.Subtract,
              TokenType.Add,
              TokenType.Multiply,
              TokenType.Divide,
          };

          for (TokenType type : types) {
              if (tokensContainType(tokens, type)) {
                  return findFirstOccuranceOfTypeInTokens(tokens, type);
              }
          }
          return 0;
      }
#+end_src

At the beginning of the method, there is an array of TokenTypes called
types. This array is then iterated over in a foreach loop to see if a type
is present in the provided tokens and returns its position in the list
of tokens if it is, exiting the method. The order of the array is important,
the operations with the greatest precedence are located towards the end
of the array. This means that when the intermediate representation is generated,
the operators with greater precedence are evaluated first, as they are
closest to the furthest away leaves of the tree created by the expression.
For example:

#+begin_src text
print 2 + 3 * 4;
#+end_src

becomes:

#+begin_src text
  {Multiply        3               4               t0             }
  {Add             2               t0              t1             }
  {Print           null            null            t1             }
#+end_src

*** Intermediate Representation Details

In my compiler, the intermediate representation takes the form of a collection
of a custom Java object, referred to in the compiler code as a IntermediateCodeInstruction.
It holds three strings and a instance of an enum. The enum refers to the
type of instruction (e.g. assignment, goto), two of the strings refer to
the arguments of the operation (which can be a value or the name of a variable),
and the final string refers to where the result will be stored. This design
is based on the quadruple concept discussed in the Dragon book \citep{dragon}{p.
366}.

You might wonder why I chose to use a string as the datatype for the arguments
and the result regardless of whether the value of the argument is an integer
or a variable. This is because the next and final stage after the creation
of the intermediate representation is code generation; the generation of
assembly. As the output of the code generation stage is a string containing
the outputted assembly, it makes sense to keep the arguments and results
as strings to allow for easy concatenation.

*** Generation of Assembly

In source code for assembly language programs, you need to assign memory
for variables in the .bss section of a NASM file. For example, if you wanted
to have a variable called exampleNumber, you would need some code like
this:

#+begin_src asm
  section .bss
      exampleNumber:   resb   4
#+end_src

In the assembly code that JPLcompiler emits, variables like the one above
are declared in order to reserve memory for three different types of variable.

- Variables declared in the source program, taken from the symbol table of the syntax tree produced by the parser

- Temporary variables, used to hold the results of operations in an expression, such as 1 + 1.

- Parameter variables, used to hold values passed as arguments to functions declared in the source program.

These memory locations are then used in the .text section like this \citep{assembly}:

#+begin_src asm
  section .text
      mov     eax     [exampleNumber]
#+end_src

This method of handling the storage definitely has its drawbacks (detailed
later on in this report) but it is a relatively uncomplicated solution
that is more understandable for a newcomer to assembly compared to an approach
that would generate more efficient assembly code. 

*** "build system"

As Java is itself a compiled language, and this project will involve many
Java files, I wrote a small bash script to compile all the Java files in
the project and then run the program. Normally in a Java project, you would
make use of a build system to do this, such as Maven. But as I want to
keep this project as simple as possible for the benefit of students, I
decided to write the aforementioned script. The only disadvantage of this
that I have been able to notice is slightly longer compile times. As the
compilation times are at most five seconds on a five year old laptop, I
don't think this is a significant disadvantage.

** Testing

A compiler is a difficult thing to test completely, as even a simple programming
language can allow for an infinite number of different source programs,
which will result in a plethora of different scenarios; each of which could
cause the compiler to fail. 

JPLcompiler has no automated testing, such as unit testing, because I felt
it would not be a good use of my time in this particular project. When
writing JPLcompiler, I have added many error checks to the code, so if
there is a problem, I will find its source very quickly. Even if an error
manages to get past the checks, the educational output that is one of the
requirements of the compiler will be clearly different to what it should
be. For example, if I wrote a program in JPL that multiplies two numbers
together and received assembly that divides two numbers, then I can look
at the output for the tokenizer, parser and intermediate code generator
to identify the source of the problem quickly and easily.

For these reasons, I have decided that the best way to test JPLcompiler
is by writing many different programs in JPL which use all of the language
features, and then using JPLcompiler to compile them. This approach to
testing will allow me to test more difficult scenarios much more quickly
than writing unit tests that only test trivial situations. It is worth
noting that JPLcompiler would be very easy to unit test due to it being
split into stages and the nature of each stages output. 

To further enhance the above strategy, I will also ask other students on
my course to try write code for my compiler. This will cause bugs to surface
that I would not be able to discover by myself.

** Installation

JPLcompiler is only designed to run on Linux. To set it up, you can run
the following commands on a debian based distribution.

#+begin_src bash
  # refresh your package listings
  sudo apt-get update

  # install necessary software
  sudo apt-get install git
  sudo apt-get install nasm
  sudo apt-get install openjdk-8-jre

  # clone the projects repository
  git clone https://github.com/lem102/finalYearProject.git
#+end_src

Once JPLcompiler has been cloned, use the script named compileAndRun.bash
with a source code file as an argument to run the compiler. 

* Evaluation
** Product Evaluation
*** Compiler is Functional

The most important requirement for me to deliver as part of this project is a
functional compiler that compiles a high-level language into a low-level
language. 

The compiler can be used to write programs that make use of variables,
flow control (such as if statements and while loops) and functions which
take parameters. 

The only data type that can be handled by the compiler is a non-negative
integer. there is also a print statement to allow output. With just these
simple features a huge variety of useful programs can be written and then
compiled with this compiler.

*** Educational Output

Another requirement of the compiler, is to emit readable output to the
user. The purpose of this output is to elucidate several concept of compilation
such as tokens syntax trees and intermediate representation. 

The compiler meets this requirement by being able to output the results
of each stage of compilation (for example the tokens created by the tokenizer).
The results can then be inspected to allow the user to gain a greater understanding
of a given part of the compilation process. 

***  Flaws of the Compiler

- Parameter Namespace Collision

The biggest problem with the compiler can be observed if, somewhere in
your program, you have a variable called apple and somewhere else you have
a parameter also called apple. In a commercial compiler this would not
cause a problem; however in JPLcompiler this will cause a problem because
the compiler will make two variables of the same name. This causes illegal
assembly to be generated, which NASM will refuse to compile. 

This problem could be avoided by implementing a special procedure that
generates variable names to be used to refer to parameters within assembly
in a similar way to how variable names for temporary variables are generated
for use in expressions.

- Only One Type

In the compiler there is only one data type, an unsigned integer. There
is only one data type because I was concerned if I spent too long implementing
other data types, like string or boolean, I would be more pressed for time
when it came to developing the intermediate code generator and the assembly
generator. 

I chose an unsigned integer as the single data type to implement because
I thought it would be the simplest to implement whilst additionally allowing
for the greatest variety of programs. Due to how I have implemented the
compiler, it would be simple to add support for additional data types.
This is because I have made use of switch statements and enums in my code;
both of which can be easily extended.

- Inefficient Usage of Temporary Variables

The compiler uses temporary variables to hold the results of parts of expressions.
For example, the result of a single addition would be stored in a single
temporary variable. This works well, however it is not very memory efficient.
This is due to the fact that if there is a function that is only called
once that contains an expression, then the memory required for that expression
will always be in use. It would be better if that memory was freed up so
it could be used to store the result of another expression instead, or
the temporary variable was reused.

I chose to take a brute force approach to solve this problem in order to
deliver a functioning product as I decided that this would be too difficult
to implement in the time that I had available. This problem could be resolved
by studying in greater depth the algorithms described in the dragon book
and implementing them. 

** Project Evaluation
*** What Have I Learned?

**** learned more about OOP.

As JPLcompiler is written in the extremely object oriented language Java,
I became much more comfortable with several object oriented concepts. I
was already comfortable with the concepts of classes and objects thanks
to previous experience from university and placement work. 

While I understood the theory, my practical understanding of concepts like
polymorphism, inheritance and their benefits were lacking. Working on this
project required me to make use of both of these concepts, especially in
regards to the parser, where the class StatementNode has many subclasses
which need to make use of methods inherited from their parent class. Writing
this code has made me much more aware of the benefits of these concepts,
and much more comfortable using them in future work.

**** learned about how to run Java projects without an IDE or build tool

During my previous university work that has involved Java, we were directed
to make use of the IntelliJ IDE. One of the features of this IDE is a GUI
button that can be pressed to run the project. With what I now know after
working on this project is that pressing this button will send a command
to a build tool (e.g. gradle or maven). The build tool will then read a
project file that has been created automatically by IntelliJ, and follow
the commands within to efficiently compile the Java project (only invoke
the java compiler for files that havent been compiled before or changed
since last compilation), and then run it.

As I decided that compilation times weren't that important to me for this
particular project, I decided to write a simple bash script to invoke the
compiler for all Java files in my src directory instead of wasting time
learning how a build system worked. This introduced me to many Java concepts
such as the classpath, and how to use the command line development tools
for Java, javac (the command to invoke the compiler) and java (the command
to run the compiled files on the JVM). This dispelled a lot of the mystery
surrounding what happens when I click the magic go button in the IDE, and
improved my understanding of the important role that compilers play in
programming.

**** learnt a lot regarding the basics of assembly

The final stage of compilation in JPLcompiler is the generation of assembly.
Before I could write code that would output assembly, I first needed to
learn the basics of an assembly language so I could have an idea of what
the input to the assembly generator (the intermediate representation) would
look like in equivalent assembly.

Topics I learned about included:

- The basic structure of an assembly file.
- The syntax of assembly language.
- Allocation of memory to constants and variables.
- Loading values into the registers of the CPU.
- Storing values loaded into a register into a memory location.
- Performing simple mathematical operations on the values loaded into the registers (necessary to basic maths in JPL).
- Comparing values stored in registers (necessary for if and while statements).
- Including other assembly files into the current file (useful for reusing any assembly "functions").
- Using return and call instructions to jump to different labels in the assembly (necessary for flow control and function calls).

**** The Benefits of Using a Clean Coding Style When Going Back to Code Written a Long Time Ago

Whenever writing code, it is important to follow certain guidelines to
ensure your code is simple to read, such as splitting functions into smaller
functions where possible and giving intention-revealing names to variables
and functions. A trivial example of a non-intention-revealing function
name would be naming a function $getThem()$ instead of $getNodes()$. 

Because I followed these practices when writing JPLcompiler, the code base
is readable. It is so readable that I can go back to code I have written
four months ago (for example to fix a bug) and understand it within five
minutes. This makes adding new features, bugfixing, and other development
tasks much easier. It allows me to use my brain to solve the problem, instead
of understanding my code!

**** History of Compiler and Its Significance in Computing

The function of compilers in general was something that I had only a dim
awareness of before starting work on this project. This all changed during
the literature review for this project where I gained a great appreciation
for the significance of compilers, and how they have shaped, and continue
to shape, programming language design and use.

**** What Does a Compiler Do

This project allowed me to develop an understanding of the main purpose
of a compiler, which is allowing a programmer to use a higher level language
to describe what he wants the computer to do, instead of writing lots of
repetitive and time-consuming code in a low-level language where he has
to think about the inner workings of a CPU as well as the problem he is
trying to solve.

**** How Does a Compiler Work

Additionally I gained an understanding of the process of compilation and
the algorithms used in professional compilers. I learned how compilers
are actually a combination of two programs, a compiler front end an a compiler
back end. The front end creates the intermediate representation, and the
backend translates this into a specific target language. this target language
could be for certain types of CPUs or managed environments such as the
JVM (Java Virutal Machine) or the CLR (Common Language Runtime). And of
course I learned about the tremendous journey that is the process of compilation
into one of these target languages.

*** What Competencies/Skills Have I Developed?

As this project is quite complex in nature I developed several of my existing
skills, and discovered some new ones.

**** Clean Coding

The number of Java classes in the codebase (around forty) and the need
to keep functions small has meant that I need to be extremely careful with
regards to the naming of classes, functions and variables so I don't get
any of them confused. This difficulty gave me ample opportunity to develop
my clean coding skills.

**** Writing Assembly

While working on this project, I have developed a new skill writing assembly
code. I did this by writing some simple programs in assembly for the purpose
of aquiring an understanding of how to write programs in assembly. This
was well worth doing, as being a low-level language it is quite different
to Java or other high-level languages that I am familiar with. There is
a lot of focus on memory management, and you need to instruct the CPU exactly
what to do. All programs are made up of operators and arguments for those
operators. Each operator will have differing ways of using the arguments,
an argument might have to be loaded into a specific register for instance.
  
**** Writing Java

My Java writing skills also improved while working on this project. I became
familiar with many of the classes and methods from the Java standard library,
especially the different types of collection and the string, char and array
helper classes. 

**** Writing Bash

As described above, I made use of a bash script to automate the process
of:

- Compiling JPLcompiler.
- Running it on a JPL source code file provided as an argument to the script.
- Assembling the output of JPLcompiler with NASM.
- Linking the object file produced by NASM with the ld command.
- And finally running the executable file produced by the ld command.

Writing the script to perform the above required me to increase my knowledge
of how commands are called in bash, learn how to read the "man" (short
for manual) pages for each command in order to figure out which command
flags I need, and understand how I can use if statements to prevent further
parts of the script from running if there is a problem when running any
of the commands in the script.

**** Designing a Large Solo Project (computer science thinking)

JPLcompiler is definitely the largest program I have written so far. Because
of this I have had to think about the structure of the program in far greater
detail than I ever have before in my previous work, where the program would
be either trivial in size, or I would just be working on a small part of
it (usually the case during my placement year). For instance, this is the
first time I have had to consider class hierarchy in a program. It is also
my first serious use of inheritance.

**** Use of Git

To prevent the loss of progress due to events out of my control, such as
hard drive failure or powercuts, I made use of the git version control
system. I have used git before, but again, never on a project of this scale.
While working on this project I made use of branches whenever I was working
on a new feature to protect the existing work on the master branch.

*** Self-Criticism/Reflection

**** I Should Have Put More Thought into the Design of the Parser Before I Started Writing It

When I started the second major stage of JPLcompiler (the parser), I foolishly
tried to write it with very little planning. This resulted in a single,
very large class that I eventually had to perform major refactoring on;
I couldn't make progress on implementing the rest of the parser as the
code was so needlessly complicated. After the refactoring development proceeded
smoothly as I had split up the code and moved the various sections to more
relevant classes. If I had spent some time thinking about the parser's
structure before jumping in, I could have saved myself a lot of pain.

**** I Wish I Could Have Employed Some Smarter Techniques for Developing Efficient Machine Code (time constraints)

In the code generation section, I would have liked to implement a more
advanced algorithm for generating efficient machine code. A commerical
compiler would be able to reduce the number of instructions required to
create equivalent but faster assembly. A commerical compiler would also
be able to reduce the number of temporary variables used in evaluating
expressions, and additionally make better use of the temporary variables
created \citep{dragon}{p. 544}.

**** I Think I Have Done a Good Job in Regards to Clean Coding, But the Class Tree of the Nodes of the Parser May be Unnecessarily Complicated

For the parser, I made use of several node classes to represent the AST
(Abstract Syntax Tree). There was one node for each type of statement.
all of the nodes extended a StatementNode class, which implemented a Node
interface. Examples of such nodes would be a DeclarationNode, which is
the node created to correspond to a variable declaration in the source
code. I think that this structure may be unnecessarily complicated, as
I'm not sure what purpose the Node interface serves. This could have been
avoided if I had thought more carefully about the class structure beforehand.

**** Discovered Many of the Flaws of Java

One of my regrets of this project is that i could not come up with a better
language to write it in than Java. Java is not a bad language, but i feel
it is very complicated sometimes to do things that should be simple; and
these solutions are often quite difficult to read due to their verbosity. 

A good example of complexity can be found in Java's concept of collection.
in python, there is the list datatype. that is the only type in the language
that concerns itself with a collection of single items. in java however,
there is the traditional array, then 33 classes that are all different
types of collection! this can waste a lot of development time, as i needed
to think about which was the most suitable one to use. some of these lists
seem to be "deprecated", as newer versions of java have added collections
that seem to do very little differently to their older counterparts but
are somehow "better".

* Conclusions
** Summary

Overall, I think this project has gone very well. I successfully created
a working compiler that can assist the learning of students in this area
to some extent. There were a couple of times during development that I
had doubts about whether I was capable of creating anything that would
be functional, however I am very pleased with the fact that it actually
works! This project has really put my skills to the test, and pushed me
to develop a much deeper understanding of compilers, programming languages
and more.

** Future Plans

If I had another year to work on this project there are a few things I
would add.

Firstly, I would add more data types, for instance strings and boolean values.
More data types would allow for more useful programs to be created, espesially
in the case of strings as this would allow for text to be displayed and
user input to be read. Including this feature would also allow for interesting
and complex topics such as type systems to be explored within the compiler.

Secondly, I would like to make the parser output (syntax tree) be more
legible. I would do this by writing a class that takes the syntax tree
as input and creates a graphical reprisentation of the syntax tree. I would
like to add this feature to the compiler because unlike the other outputs
of the compiler, the text reprisentation of the syntax tree is very difficult
to read, and therefore difficult to understand for the user.

Thirdly, I would like to improve the efficiency of the output of the assembly
generator so that the assembly code generated makes more efficiant use
of registers and memory. This would benefit the project as it would allow
the student to see more complex assembly generation.

\bibliography{bibliography.bib}
